package frc.robot.commands;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.Constants;
import frc.robot.subsystems.ArmSubsystem;
import frc.robot.subsystems.IntakeSubsystem;
import frc.robot.subsystems.SwerveDriveSubsystem;

public
class AutoTwoPieceAndBalance extends CommandBase {

	Timer timer = new Timer();
	SwerveDriveSubsystem swerveDriveSubsystem;
	ArmSubsystem armSubsystem;
	IntakeSubsystem intakeSubsystem;
	Boolean bSecondTime = false;

  public
	AutoTwoPieceAndBalance(SwerveDriveSubsystem subsystem, ArmSubsystem arm,
	                       IntakeSubsystem intake) {
		addRequirements(subsystem);
		swerveDriveSubsystem = subsystem;
		addRequirements(arm);
		armSubsystem = arm;
		addRequirements(intake);
		intakeSubsystem = intake;
	}

	@Override public void initialize() {
		timer.reset();
		timer.start();
	}

  public
	void TwoGamePiece() {
		switch (Constants.eTwoPieceBalance) {
		case none:
			break;

		case raiseArm:
			if (armSubsystem.armEncoder.getPosition() >
			    -270 /*Constants.maxLeadscrewRotations * 16 /*Gearbox ratio */) {
				armSubsystem.LiftArm(-0.6);

				if (armSubsystem.armEncoder.getPosition() > -200) {
					armSubsystem.ClawRotation(0.4);
				}
			} else {
				Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.extendArm;
				break;
			}

		case extendArm:
			armSubsystem.ExtendArm(true);
			Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.placePiece;
			break;

		case placePiece:
			timer.reset();
			timer.start();
			if (!timer.hasElapsed(0.2)) {
				armSubsystem.ClawRotation(-0.4);
			}
			if (!timer.hasElapsed(0.2 + 0.2)) {
				intakeSubsystem.ClawOutake();
			} else {
				timer.stop();
				timer.reset();
				if (!bSecondTime) {
					Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.driveToGamepiece;
				} else {
					Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.driveToBalance;
					break;
				}
			}
		case driveToGamepiece:
			timer.start();
			if (!timer.hasElapsed(2.3)) {
				if (armSubsystem.armEncoder.getPosition() < -51) {
					armSubsystem.LiftArm(0.6);
				}
				swerveDriveSubsystem.driveFieldCentric(.5, 0, 0.2);
			} else {
				Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.pickupPiece;
				break;
			}

		case pickupPiece:
			timer.stop();
			timer.reset();
			if (armSubsystem.armEncoder.getPosition() > -80) {
				armSubsystem.LiftArm(-0.2);
				if (armSubsystem.clawEncoder.getPosition() <) {
					armSubsystem.ClawRotation(0.3);
				}
			} else {
				timer.start();
				if (timer.hasElapsed(0.2)) {
					intakeSubsystem.ClawIntake();
				} else {
					Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.driveToGrid;
					break;
				}
			}

		case driveToGrid:
			if (timer.hasElapsed(2.3 + 0.2)) {
				swerveDriveSubsystem.driveFieldCentric(-0.5, 0, -0.2);
			} else {
				bSecondTime = true;
				Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.raiseArm;
			}

		case driveToBalance:
			timer.reset();
			timer.start();
			if (timer.hasElapsed(0.9)) {
				swerveDriveSubsystem.driveRobotCentric(0, 0.5, 0);
			} else {
				Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.autoBalance;
			}

		case autoBalance:
			if (Constants.gyro.getPitch() == 0) {
				swerveDriveSubsystem.driveRobotCentric(-0.3, 0, 0);
			} else {
				if (Constants.gyro.getPitch() != 0) {
					swerveDriveSubsystem.driveRobotCentric(
						OcrMath.clamp(-autoBalancePID.calculate(Constants.gyro.getPitch(), 0), 0.3,
					                  0.3),
						0, 0);
				} else {
					Constants.eTwoPieceBalance = Constants.twoPieceBalanceEnum.none;
				}
			}
		}
	}
}
